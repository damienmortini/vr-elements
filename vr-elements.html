<link rel="import" href="../polymer/polymer.html">

<!--
Element providing solution to no problem in particular.

##### Example

    <vr-element></vr-element>

@element vr-element
@blurb Element providing solution to no problem in particular.
@status alpha
@homepage http://dmmn.github.io/vr-element
-->
<polymer-element name="vr-element" attributes="nosplit">

  <template>
    <style>
      :host {
        display: block;
        position: relative;
      }
      :host #vrMainContainer, :host #vrMainContent, :host #vrSideContainer, :host #vrSideContent {
        position: absolute;
        height: 100%;
        top: 0;
      }
      :host(:not(.vr-splitted)) #vrMainContainer, :host(:not(.vr-splitted)) #vrMainContent {
        width: 100%;
        left: 0;
      }
      :host(:not(.vr-splitted)) #vrSideContainer {
        display: none;
      }
      :host(.vr-splitted) #vrMainContainer, :host(.vr-splitted) #vrSideContainer {
        overflow: hidden;
        width: 50%;
      }
      :host(.vr-splitted) #vrMainContent, :host(.vr-splitted) #vrSideContent {
        width: 120%;
      }
      :host(.vr-splitted) #vrMainContainer, :host(.vr-splitted) #vrMainContent {
        left: 0;
      }
      :host(.vr-splitted) #vrSideContainer, :host(.vr-splitted) #vrSideContent {
        right: 0;
      }
    </style>
    <div id="vrMainContainer">
      <div id="vrMainContent">
        <content></content>
      </div>
    </div>
    <div id="vrSideContainer">
      <div id="vrSideContent"></div>
    </div>
  </template>

  <script>

    Polymer('vr-element', {

      created: function() {
        this.hmdVRDevice = null; 
        this.positionSensorVRDevice = null;
      },

      domReady: function() {
        if(this.nosplit === null) {
          setTimeout(this.split.bind(this), 0);
        }
      },

      split: function() {

        // MUTATION OBSERVER
        
        var observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            switch (mutation.type) {
              case 'childList':
                for (var i = 0, l = mutation.addedNodes.length; i < l; i++) {
                  var element = mutation.addedNodes[i];
                  if(element.nodeType === Node.TEXT_NODE) {
                    element.parentNode.linkedElement.innerText = element.data;
                    continue;
                  }
                  mutation.target.linkedElement.appendChild(cloneAndLinkElement(element));
                };
                for (var i = 0, l = mutation.removedNodes.length; i < l; i++) {
                  mutation.removedNodes[i].linkedElement.remove();
                };
                break;
              case 'attributes':
                if (mutation.attributeName === 'style') {
                  copyStyles(mutation.target, mutation.target.linkedElement);
                }
                else if (mutation.attributeName === 'class') {
                  mutation.target.linkedElement.className = mutation.target.className;
                }
                else {
                  mutation.target.linkedElement[mutation.attributeName] = mutation.target[mutation.attributeName];
                }
                break;
              case 'characterData':
                mutation.target.parentNode.linkedElement.innerHTML = mutation.target.parentNode.innerHTML;
                break;
            }
            var changedAttribute = mutation.target[mutation.attributeName];
          });    
        });

        var mutationObserverConfig = { attributes: true, childList: true, characterData: true};

        // COPY

        console.warn('TEMP: Need to target also ::shadow in css to have style into Shadow Dom (for right eye).');

        this.classList.add('vr-splitted');

        function copyStyles(mainElement, copyElement) {
          // Old fashion way without need of shadow in css but doesn't properly copy transitions
          // 
          // mainElement.hidden = copyElement.hidden = true;
          // var styleMain = getComputedStyle(mainElement);
          // var styleCopy = getComputedStyle(copyElement);
          // for (var i = 0; i < styleMain.length; i++) {
          //   var property = styleMain[i];
          //   if(styleMain[property] !== styleCopy[property]) {
          //     copyElement.style[property] = styleMain[property];
          //   }
          // };
          // mainElement.hidden = copyElement.hidden = false;
          // 

          for (var i = 0; i < mainElement.style.length; i++) {
            var property = mainElement.style[i];
            copyElement.style[property] = mainElement.style[property];
          };
        };

        function cloneAndLinkElement(element) {
          var clone = element.cloneNode();

          element.linkedElement = clone;

          observer.observe(element, mutationObserverConfig);

          if(element.style) {
            copyStyles(element, clone);
          }

          var children;
          if(element.childNodes) {
            for (var i = 0; i < element.childNodes.length; i++) {
              clone.appendChild(cloneAndLinkElement(element.childNodes[i]));
            };
          }

          if(element.shadowRoot) {
            observer.observe(element.shadowRoot, mutationObserverConfig);

            clone.shadowRoot.innerHTML = '';
            for (var i = 0; i < element.shadowRoot.childNodes.length; i++) {
              clone.shadowRoot.appendChild(cloneAndLinkElement(element.shadowRoot.childNodes[i]));
            };
          }

          return clone;
        };

        function onElementScroll (e) {
          e.target.linkedElement.scrollTop = e.target.scrollTop;
          e.target.linkedElement.scrollLeft = e.target.scrollLeft;
        }

        for (var i = 0; i < this.childNodes.length; i++) {
          this.$.vrSideContent.appendChild(cloneAndLinkElement(this.childNodes[i]));
        };

        this.addEventListener('scroll', onElementScroll, true);
      },

      getSensor: function () {
        return new Promise(function(resolve, reject) {
          function onGetVRDevices(vrDevices) {
            for (var i = 0; i < vrDevices.length; i++) {
              if (vrDevices[i] instanceof HMDVRDevice) {
                this.hmdVRDevice = vrDevices[i];
                break;
              }
            }
            for (var i = 0; i < vrDevices.length; i++) {
              if (vrDevices[i] instanceof PositionSensorVRDevice && vrDevices[i].hardwareUnitId === this.hmdVRDevice.hardwareUnitId) {
                this.positionSensorVRDevice = vrDevices[i];
                break;
              }
            }
            if (!this.hmdVRDevice || !this.positionSensorVRDevice) {
              reject(Error('Couldn\'t find any VR Device and/or sensor!'));
              return;
            }
            resolve({positionSensorVRDevice: this.positionSensorVRDevice});
          }

          if (navigator.getVRDevices) {
            navigator.getVRDevices().then(onGetVRDevices.bind(this));
          }
          else if (navigator.mozGetVRDevices) {
            navigator.mozGetVRDevices(onGetVRDevices.bind(this));
          }
          else {
            var error = 'Your current browser doesn\'t have support for navigator.getVRDevices yet, please download Chromium here http://blog.tojicode.com/2014/07/bringing-vr-to-chrome.html or Firefox Nightly here http://blog.bitops.com/blog/2014/06/26/first-steps-for-vr-on-the-web';
            console.warn(error);
            reject(error);
          }
        });
      },

      requestFullscreen: function () {
        if (this.webkitRequestFullscreen) {
          this.webkitRequestFullscreen({ vrDisplay: this.hmdVRDevice });
        } else if (this.mozRequestFullScreen) {
          this.mozRequestFullScreen({ vrDisplay: this.hmdVRDevice });
        }
      }

    });

  </script>

</polymer-element>

<!--
Element providing solution to no problem in particular.

##### Example

    <vr-button></vr-button>

@element vr-button
@blurb Element providing solution to no problem in particular.
@status alpha
@homepage http://dmmn.github.io/vr-button
-->
<polymer-element name="vr-button" noscript>

  <template>
    <style>
      :host {
        box-sizing: border-box;
        display: inline-block;
        vertical-align: middle;
        background-color: white;
        box-shadow: 0 2px 10px 0 rgba(0,0,0,.26);
        margin: 10px;
        cursor: pointer;
        border-radius: 20px;
        padding: 10px;
        border-radius: 20px;
      }
      :host svg {
        display: inline-block;
        width: 18px;
      }
    </style>
    <svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
       viewBox="0 211.6 1000 576.8" enable-background="new 0 211.6 1000 576.8" xml:space="preserve">
    <path fill="#000000" d="M958,211.6H42c-21.6,0-39,17.5-39,39v498.7c0,21.6,17.5,39,39,39h325.4c10.8,0,20.4-7.2,23.4-17.6
      c36.5-125.4,44-196.9,112.8-196.9c68.7,0,78.9,81.7,111.2,197.4c2.8,10.1,12,17,22.5,17H958c21.6,0,39-17.5,39-39V250.7
      C997,229.1,979.6,211.6,958,211.6z M277.5,603.7c-57.3,0-103.7-46.4-103.7-103.7s46.4-103.7,103.7-103.7S381.1,442.7,381.1,500
      S334.7,603.7,277.5,603.7z M722.5,603.7c-57.3,0-103.7-46.4-103.7-103.7s46.4-103.7,103.7-103.7c57.3,0,103.7,46.4,103.7,103.7
      S779.8,603.7,722.5,603.7z"/>
    </svg>
    <content></content>
  </template>

</polymer-element>
